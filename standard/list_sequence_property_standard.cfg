[DEFAULT]
workspace = /home/shilei/fbpmx/list_sequence_standard/list_sequence_property_standard_${date}

[project]
actions = generate, train
datasets = raw_sequence_list_trans, sequence_list_property_fixed_label
models = sequence_list_property_model
stages = sequence_list_spec_split_export

[dataset_raw_sequence_list]
class = ReadExcelDataset
dir = /home/shilei/corpus/list_sequence/清单工序0904.xlsx


[dataset_raw_sequence_list_trans]
class = MapDataset
input = raw_sequence_list
expression = exec('import re; import uuid') or {"item_id": uuid.uuid3(uuid.NAMESPACE_DNS, str(x["filepath"]).split("/")[-1].split(".xlsx")[0] + "-" + str(x["uid"])).hex,
    "uid": str(x["uid"]),
    "pid": str(x["filepath"]).split("/")[-1].split(".xlsx")[0],
    "list_key": str(x["filepath"]).split("/")[-1].split(".xlsx")[0] + "-" + str(x["uid"]),
    "工序预期": ",".join(sorted(set(x["工序0904修改"].split("|")))) if x["工序0904修改"] is not None else "",
    }
keep_exists = True


[dataset_raw_sequence_list_dedup]
class = AccumulateDataset
input = raw_sequence_list_trans
deduplicate_by = list_key


[dataset_raw_sequence_list_rebuild]
class = ListCaptionSpecRebuildDataset
input = raw_sequence_list_dedup
caption_key = caption
spec_key = spec
caption_keywords = 项目名称
spec_keywords = 项目特征
sep_keywords = 项目特征,工作内容,工程内容


[stage_sequence_list_meta_data_export]
class = DatasetExportStage
dataset = raw_sequence_list_rebuild
output_fields = pid, uid, list_key, project_node_name, full_name, caption, spec, caption_rebuild, spec_rebuild
output_names = 工程id, uid, 清单id, 工程名称, 上级名称, caption, spec, caption_rebuild, spec_rebuild
save_res_path = /home/shilei/fbpmx/list_sequence_standard/list_sequence_property_standard_${date}/sequence_list_meta_data_export_${date}.xlsx


[dataset_sequence_list_spec_split]
class = ListSpecSplitDataset
input = raw_sequence_list_rebuild
spec_key = spec_rebuild


[dataset_sequence_list_spec_split_trans]
class = MapDataset
input = sequence_list_spec_split
expression = exec('import re; import uuid') or {
    "split_id": uuid.uuid3(uuid.NAMESPACE_DNS, str(x["filepath"]).split("/")[-1].split(".xlsx")[0] + "-" + str(x["uid"]) + str(x["spec_rebuild_split"])).hex,

    "split_name": str(x["spec_rebuild_split"]) if x["spec_rebuild_split"] is not None else "",
    "item_name": str(x["caption_rebuild"]) if x["caption_rebuild"] is not None else "",
    "item_feature": str(x["spec_rebuild"]) if x["spec_rebuild"] is not None else "",
    "upper_item_name": str(x["full_name"]) if x["full_name"] is not None else "",

    "split_name_wk": f'特征分句: {x["spec_rebuild_split"]}' if x["spec_rebuild_split"] is not None and len(str(x["spec_rebuild_split"]))>0 else "",
    "item_name_wk": f'清单名称: {x["caption_rebuild"]}' if x["caption_rebuild"] is not None and len(str(x["caption_rebuild"]))>0 else "",
    "item_feature_wk": f'清单特征: {x["spec_rebuild"]}' if x["spec_rebuild"] is not None and len(str(x["spec_rebuild"]))>0 else "",
    "upper_item_name_wk": f'全路径: {x["full_name"]}' if x["full_name"] is not None and len(str(x["full_name"]))>0 else "",
    }
keep_exists = True


[stage_sequence_list_spec_split_export]
class = DatasetExportStage
dataset = sequence_list_spec_split_trans
output_fields = pid, uid, list_key, project_node_name, full_name, caption, spec, caption_rebuild, spec_rebuild, split_id, spec_rebuild_split
output_names = 工程id, uid, 清单id, 工程名称, 上级名称, caption, spec, caption_rebuild, spec_rebuild, split_id, spec_rebuild_split
save_res_path = /home/shilei/fbpmx/list_sequence_standard/list_sequence_property_standard_${date}/sequence_list_spec_split_export_${date}.xlsx


############################## 修改标注 ####################################


[dataset_sequence_list_spec_split_sequence_fixed]
class = ReadExcelDataset
dir = /home/shilei/corpus/list_sequence/清单工序_标准校核.xlsx
header_row = 0

[dataset_sequence_fixed]
class = MapDataset
input = sequence_list_spec_split_sequence_fixed
expression = {"split_id": x["split_id"],
    "工序预期修改": "" if x["工序预期"] == "无工序" else None if x["工序预期"] is None else ",".join(sorted(set(x["工序预期"].split(",")))),
    "工序数值属性原始预期": None if x["工序数值属性原始预期"] == "无工序属性" else x["工序数值属性原始预期"],
    }

[dataset_sequence_fixed_label]
class = MapDataset
input = sequence_fixed
expression = {
    "sequence_label": list(sorted( map( lambda x: "=$=".join( [x, "1"] ), x["工序预期修改"].split(",") )  )) if "工序预期修改" in x and x["工序预期修改"] is not None and len(x["工序预期修改"])>0 else [],
    "工序_数值属性名称预期": sorted(set(map(lambda x: "_".join(x.split("=#=")[:2]), x["工序数值属性原始预期"].split("|")))) if x["工序数值属性原始预期"] is not None else [],

    "sequence_num_property_label": sorted(set(map(lambda x: "=$=".join( [ "_".join(x.split("=#=")[:2]) ] + [ "".join( map( lambda x: f'{round(float(x["std"])*1e4)}'.zfill(8), eval(x.split("=#=")[2]) ) )  if len( eval(x.split("=#=")[2]) ) == 2 else "".join( map( lambda x: f'{round(float(x["std"])*1e4)}'.zfill(8) + "0"*8 if x["flag"] == "single" or ( "sign" in x and x["sign"] in [ "upper", "upperorequal", ] ) else "0"*8 + f'{round(float(x["std"])*1e4)}'.zfill(8) if "sign" in x and x["sign"] in [ "lower", "lowerorequal", ] else "0"*16 , eval(x.split("=#=")[2]) ) ) if len( eval(x.split("=#=")[2]) ) == 1 else "0"*16  ] ) , x["工序数值属性原始预期"].split("|")))) if x["工序数值属性原始预期"] is not None else [],
    "sequence_num_range_label": sorted( set( map( lambda x: "=$=".join( [ "_".join(x.split("=#=")[:2]) ] + [ "_".join( map( lambda x: x["flag"] if "sign" not in x or x["sign"] is None else x["sign"], eval(x.split("=#=")[2]) ) ) if len( eval(x.split("=#=")[2]) ) == 2 else "".join( map( lambda x: f'{x["flag"]}_None' if x["flag"] == "single" else f'{x["sign"]}_None' if "sign" in x and x["sign"] in ["upper", "upperorequal"] else f'None_{x["sign"]}' if "sign" in x and x["sign"] in ["lower", "lowerorequal"] else "None_None", eval(x.split("=#=")[2]) ) ) if len( eval(x.split("=#=")[2]) ) == 1 else "None_None" ] ) , x["工序数值属性原始预期"].split("|") ) ) ) if x["工序数值属性原始预期"] is not None else [],
    "sequence_num_unit_label": sorted( set( map( lambda x:  "=$=".join( [ "_".join(x.split("=#=")[:2]) ] + [ "_".join( map( lambda x: "None" if len(x["unit"]) <= 0 else x["unit"].lower(), eval(x.split("=#=")[2]) ) ) if len( eval(x.split("=#=")[2]) ) == 2 else "".join( map( lambda x: "None_None" if len(x["unit"]) <= 0 else f'{x["unit"].lower()}_None' if x["flag"] == "single" or ( "sign" in x and x["sign"] in ["upper", "upperorequal"] ) else f'None_{x["unit"].lower()}' if "sign" in x and x["sign"] in ["lower", "lowerorequal"] else "None_None", eval(x.split("=#=")[2]) ) ) if len( eval(x.split("=#=")[2]) ) == 1 else "None_None" ] ) , x["工序数值属性原始预期"].split("|") ) ) ) if x["工序数值属性原始预期"] is not None else [],

;     "sequence_label": list(sorted(x["工序预期修改"].split(","))) if "工序预期修改" in x and x["工序预期修改"] is not None and len(x["工序预期修改"])>0 else [],
;     "工序_数值属性名称预期": sorted(set(map(lambda x: "_".join(x.split("=#=")[:2]), x["工序数值属性原始预期"].split("|")))) if x["工序数值属性原始预期"] is not None else [],
;     "sequence_num_property_label": sorted(set(map(lambda x: "_".join(x.split("=#=")[:2]+[ "".join( map( lambda x: f'{round(float(x["std"])*1e4)}'.zfill(8), eval(x.split("=#=")[2]) ) )  if len( eval(x.split("=#=")[2]) ) == 2 else "".join( map( lambda x: f'{round(float(x["std"])*1e4)}'.zfill(8) + "0"*8 if x["flag"] == "single" or ( "sign" in x and x["sign"] in [ "upper", "upperorequal", ] ) else "0"*8 + f'{round(float(x["std"])*1e4)}'.zfill(8) if "sign" in x and x["sign"] in [ "lower", "lowerorequal", ] else "0"*16 , eval(x.split("=#=")[2]) ) ) if len( eval(x.split("=#=")[2]) ) == 1 else "0"*16  ] ) , x["工序数值属性原始预期"].split("|")))) if x["工序数值属性原始预期"] is not None else [],
;     "sequence_num_range_label": sorted( set( map( lambda x: "_".join( x.split("=#=")[:2] + [ "_".join( map( lambda x: x["flag"] if "sign" not in x or x["sign"] is None else x["sign"], eval(x.split("=#=")[2]) ) ) if len( eval(x.split("=#=")[2]) ) == 2 else "".join( map( lambda x: f'{x["flag"]}_None' if x["flag"] == "single" else f'{x["sign"]}_None' if "sign" in x and x["sign"] in ["upper", "upperorequal"] else f'None_{x["sign"]}' if "sign" in x and x["sign"] in ["lower", "lowerorequal"] else "None_None", eval(x.split("=#=")[2]) ) ) if len( eval(x.split("=#=")[2]) ) == 1 else "None_None" ] ) , x["工序数值属性原始预期"].split("|") ) ) ) if x["工序数值属性原始预期"] is not None else [],
;     "sequence_num_unit_label": sorted( set( map( lambda x: "_".join( x.split("=#=")[:2] + [ "_".join( map( lambda x: "None" if len(x["unit"]) <= 0 else x["unit"].lower(), eval(x.split("=#=")[2]) ) ) if len( eval(x.split("=#=")[2]) ) == 2 else "".join( map( lambda x: "None_None" if len(x["unit"]) <= 0 else f'{x["unit"].lower()}_None' if x["flag"] == "single" or ( "sign" in x and x["sign"] in ["upper", "upperorequal"] ) else f'None_{x["unit"].lower()}' if "sign" in x and x["sign"] in ["lower", "lowerorequal"] else "None_None", eval(x.split("=#=")[2]) ) ) if len( eval(x.split("=#=")[2]) ) == 1 else "None_None" ] ) , x["工序数值属性原始预期"].split("|") ) ) ) if x["工序数值属性原始预期"] is not None else [],
    }
keep_exists = True


[dataset_sequence_list_property_fixed_label]
class = MergeIntoDataset
base_dataset = sequence_list_spec_split_trans
merge_datasets = sequence_fixed_label
merge_type = only_replace
merge_key = split_id
merge_values = 工序预期修改, sequence_label, 工序数值属性原始预期, 工序_数值属性名称预期, sequence_num_property_label, sequence_num_range_label, sequence_num_unit_label
reset = False

############################# 扩展随机正例 ###############################################

[dataset_num_property_oversampling_data]
class = NumberLabelOverSamplingDataset
input = sequence_list_property_fixed_label
feature_keys = item_name_wk, item_feature_wk
label_key = 工序数值属性原始预期
over_sample_num = 10
min_int = 0
max_int = 1000
max_decimal_places = 2
float_probability = 0.5


[dataset_num_property_oversampling_data_label]
class = MapDataset
input = num_property_oversampling_data
expression = exec('import re; import uuid') or {
    "sequence_num_property_label": sorted(set(map(lambda x: "_".join(x.split("=#=")[:2]+[ "".join( map( lambda x: f'{round(float(x["std"])*1e4)}'.zfill(8), eval(x.split("=#=")[2]) ) )  if len( eval(x.split("=#=")[2]) ) == 2 else "".join( map( lambda x: f'{round(float(x["std"])*1e4)}'.zfill(8) + "0"*8 if x["flag"] == "single" or ( "sign" in x and x["sign"] in [ "upper", "upperorequal", ] ) else "0"*8 + f'{round(float(x["std"])*1e4)}'.zfill(8) if "sign" in x and x["sign"] in [ "lower", "lowerorequal", ] else "0"*16 , eval(x.split("=#=")[2]) ) ) if len( eval(x.split("=#=")[2]) ) == 1 else "0"*16  ] ) , x["工序数值属性原始预期"].split("|")))) if x["工序数值属性原始预期"] is not None else [],
    }
keep_exists = True


########################################################################################

[dataset_sequence_list_property_train]
class = FilterDataset
input = num_property_oversampling_data_label
filters = int(x["item_id"][-5:],16) % 10 >= 2

[dataset_sequence_list_property_test]
class = FilterDataset
input = num_property_oversampling_data_label
filters = int(x["item_id"][-5:],16) % 10 < 2


[model_sequence_list_property_model]
class = MultiHeadNumClassificationModelV3
data = sequence_list_property_train
bert_base = /home/shilei/model_repository/chinese-roberta-wwm-ext_ft
text_key = split_name_wk
extra_feats = upper_item_name_wk, item_name_wk, item_feature_wk
cate_label_delimiter = "=$="
label_delimiter = "_"
labels_delimeter = |
label_key = "工序": "sequence_label", "工序数值属性": "sequence_num_property_label", "工序数值属性范围": "sequence_num_range_label", "工序数值属性单位": "sequence_num_unit_label"
labels = "工序"::"加固处理|勾缝处理|涂料喷刷|磨光|打蜡|防滑处理|裱糊处理|刚性层处理|排气处理|排水处理|垫层处理|基层处理|回填|钢筋焊接|植筋|塞口处理|龙骨安装|嵌缝|吊杆安装|防腐处理|抹灰|防锈处理|隔离处理|底层处理|找平|找坡|结合处理|保温处理|防水处理|隔气处理|防护处理|面层处理|中层漆喷刷|底漆喷刷|房心回填|块料挂贴|干挂|湿挂|基层板安装";"工序数值属性"::"基层板安装_厚度|涂料喷刷_厚度|刚性层处理_厚度|排水处理_厚度|垫层处理_厚度|基层处理_厚度|回填_厚度|防腐处理_厚度|抹灰_厚度|隔离处理_厚度|底层处理_厚度|找平_厚度|找坡_厚度|结合处理_厚度|保温处理_厚度|防水处理_厚度|隔气处理_厚度|防护处理_厚度|面层处理_厚度|中层漆喷刷_厚度|底漆喷刷_厚度|房心回填_厚度|块料挂贴_厚度|干挂_厚度|湿挂_厚度"
label_count = "工序": 1, "工序数值属性": 16, "工序数值属性范围": 2, "工序数值属性单位": 2
label_dim = "工序": ["1"],,"工序数值属性": ["0","1","2","3","4","5","6","7","8","9"],,"工序数值属性范围": ["None", "single", "upper", "upperorequal", "lower", "lowerorequal"],,"工序数值属性单位": ["None", "mm", "cm", "dm", "m", "km", "m2", "m3", "g", "kg", "t", "°", "%", "ma", "a", "kw", "个", "kg/m3", "m3/h", "μm"]
label_mapping = "工序数值属性范围": "工序数值属性", "工序数值属性单位": "工序数值属性"
num_labels = 4
learning_rate = 2.0e-5
num_epochs = 200
train_ratio = 0.85
batch_size = 256
max_seq_length = 128
